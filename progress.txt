## Codebase Patterns
- Use TypeScript enums with string values for database column values (e.g., Tier.HOT = "HOT")
- Use ISO 8601 date strings for all timestamp fields
- Use JSDoc comments on interfaces and enums to document purpose and half-lives
- JSON arrays stored as strings in SQLite (e.g., use_days)

- Use better-sqlite3 for synchronous SQLite operations with TypeScript
- Enable WAL mode (journal_mode = WAL) for concurrency
- Use INTEGER for boolean columns (do_not_inject, pinned) with 0/1 values
- Foreign key constraints supported but need PRAGMA foreign_keys = ON for enforcement

- FTS5 uses content='' with content_rowid for external content tables (sync via triggers)
- BM25 scores in FTS5 are negative; negate for intuitive ranking (higher = more relevant)
- Cache prepared statements for performance (e.g., searchStmt in FTS5Helper)
- Handle FTS5 query syntax errors by falling back to phrase search with escaped quotes

- @xenova/transformers provides fully offline embedding inference via ONNX runtime
- Cache model pipelines after first load (use initPromise pattern to prevent concurrent initialization)
- Use mean pooling + normalization for sentence embeddings
- Common model dimensions: MiniLM = 384, mpnet/gte-base/e5-base = 768

- OpenAI embedding models: text-embedding-3-small (1536), text-embedding-3-large (3072), text-embedding-ada-002 (1536)
- Use native fetch() for API calls (Node 18+); no additional HTTP library needed
- OpenAI embeddings API may return results out of order; sort by index field
- Provide specific error guidance based on HTTP status (401=auth, 429=rate limit, 400=bad input)

- sqlite-vec uses vec0 virtual table with FLOAT[N] column type for embeddings
- When sqlite-vec unavailable, store embeddings as BLOBs (Float32Array buffer)
- Cosine similarity: dot(a,b) / (||a|| * ||b||), clamp result to [0,1] for floating point safety
- Convert Buffer to Float32Array using buffer.buffer, buffer.byteOffset, buffer.byteLength/4

- MemoryScorer uses exp(-age/halflife) for recency decay; pinned memories bypass this with value 1.0
- Frequency component uses log(1+use_count) normalized by log(101)≈4.6 for reasonable scaling
- scoreWithBreakdown() provides transparency for memory_explain tool implementation

- TierBudgetAllocator allocates slots by tier: pinned (25%), HOT (45%), WARM (25%), COLD (5%)
- Use Math.floor for slot calculation to avoid over-allocation; final truncation ensures maxItems respected
- AllocationResult includes breakdown counts for each bucket and excludedCount for filtered memories
- ScoredMemory pairs Memory with score for transparent ranking

- Zod schemas: use .optional() for nested objects, then resolveConfig() applies defaults via ?? operator
- configSchema exports: { schema, parse, safeParse, resolve, uiHints } for OpenClaw plugin registration
- uiHints structure matches schema hierarchy with label, description, type fields for UI generation

- Tools use MemoryStoreResult with { content: [...], details: {...} } format for agent responses
- DUPLICATE_THRESHOLD = 0.95 for detecting similar memories via vector similarity
- Store use_days as JSON.stringify([today]) on initial creation; today = ISO date YYYY-MM-DD
- Validate and clamp importance to [0.0, 1.0] range
- MemoryRecallTool returns { content: [...], memories: [...] } format for search results
- Hybrid search fetches 3x candidates (min 30) for filtering; final limit applied after scoring
- updateAccessStats increments use_count and appends today to use_days if not already present

- Context tools use ACTIVE_CONTEXT_ID = "active" constant for the single context row
- MemorySetContextTool.getContext() implements lazy TTL expiry check; returns null and cleans up if expired
- TTL stored as seconds in DB (ttl_seconds), but tool accepts ttlHours for UX convenience
- Context expiry calculated as: createdAt.getTime() + ttl_seconds * 1000

- AutoCaptureHook captures important text from agent responses into memories
- Memory type detection uses regex patterns: procedural, project, episodic, factual (default)
- Importance scoring factors: pattern matches, code snippets (`...`), importance keywords, list structure
- DUPLICATE_THRESHOLD = 0.95 applies to auto-capture (same as memory_store tool)

- AutoRecallHook.extractKeyTerms() removes stop words and short tokens for focused search
- Format injected memories as XML: <relevant-memories><current-context>...</current-context><memory>...</memory></relevant-memories>
- Hooks receive ResolvedConfig; createAutoRecallHook() factory maps config to AutoRecallConfig

---

## 2026-01-31 - US-021
- What was implemented: Created AutoCaptureHook class for agent_end hook with automatic memory capture
- Files changed:
  - extensions/memory-tiered/hooks/auto_capture.ts (new)
- **Learnings for future iterations:**
  - AutoCaptureHook takes db, embeddingProvider, vectorHelper, and optional config as constructor dependencies
  - execute(response) extracts capturable candidates, checks duplicates, and stores as memories
  - extractCapturableCandidates() splits by paragraphs, filters by length (10-500 chars), extracts sentences if too long
  - detectMemoryType() uses MEMORY_TYPE_PATTERNS with regex matching for procedural/project/episodic/factual
  - Importance score includes: pattern match ratio, length ratio, code snippets, importance keywords, list structure
  - maxCapturesPerConversation = 3 by default; processes top-scored candidates first
  - Duplicate detection: isDuplicate() checks vectorSearch for similarity >= 0.95
  - All captured memories stored as tier='HOT', source='auto-capture', importance=0.5
  - createAutoCaptureHook() factory function maps ResolvedConfig to AutoCaptureConfig
---

## 2026-01-31 - US-020
- What was implemented: Created AutoRecallHook class for before_agent_start hook with automatic memory injection
- Files changed:
  - extensions/memory-tiered/hooks/auto_recall.ts (new)
- **Learnings for future iterations:**
  - AutoRecallHook takes db, embeddingProvider, vectorHelper, and optional config as constructor dependencies
  - execute(prompt) extracts key terms, runs hybrid search, applies tier budget allocation, and formats XML
  - extractKeyTerms() filters common stop words and short tokens, returns top 20 unique terms
  - Uses TierBudgetAllocator to respect tier budgets (pinned 25%, HOT 45%, WARM 25%, COLD 5%)
  - Budgets in config are percentages (0-100); convert to decimals (0-1) when passing to TierBudgetAllocator
  - Current context always included first in XML output via MemorySetContextTool.getContext()
  - Returns { prependContext, memoriesInjected, contextIncluded } for hook result
  - createAutoRecallHook() factory function maps ResolvedConfig to AutoRecallConfig
  - escapeXml() handles &, <, >, ", ' characters for safe XML embedding
---

## 2026-01-31 - US-019
- What was implemented: Created MemorySetContextTool and MemoryClearContextTool for managing active task context
- Files changed:
  - extensions/memory-tiered/tools/memory_set_context.ts (new)
  - extensions/memory-tiered/tools/memory_clear_context.ts (new)
- **Learnings for future iterations:**
  - MemorySetContextTool and MemoryClearContextTool only require db as constructor dependency
  - Set context uses INSERT OR REPLACE for upsert behavior on id='active'
  - Clear context returns different messages based on whether context existed
  - MemorySetContextResult includes expires_at timestamp for UI feedback
  - getContext() method on MemorySetContextTool can be reused by hooks for auto-recall
  - Lazy TTL check cleans up expired context on retrieval rather than via scheduled job
---

## 2026-01-31 - US-018
- What was implemented: Created MemoryExplainTool class for explaining memory scoring and injection eligibility
- Files changed:
  - extensions/memory-tiered/tools/memory_explain.ts (new)
- **Learnings for future iterations:**
  - MemoryExplainTool takes db, optional embeddingProvider, optional vectorHelper, and optional scorer
  - execute() returns MemoryExplainResult with content array and details object
  - Scoring explanation includes similarityValue (raw 0-1), weighted components, and totalScore
  - Injection eligibility includes: eligible (bool), reason (string), isPinned, isForgotten, tier
  - Uses vectorHelper.vectorSearch() with limit 100 to find memory's similarity for query
  - formatExplanationText() builds human-readable multi-line explanation string
  - Imports HALF_LIVES from scorer.ts for displaying memory type half-life in output
---

## 2026-01-31 - US-017
- What was implemented: Created MemoryPinTool and MemoryUnpinTool classes for pinning/unpinning memories
- Files changed:
  - extensions/memory-tiered/tools/memory_pin.ts (new)
  - extensions/memory-tiered/tools/memory_unpin.ts (new)
- **Learnings for future iterations:**
  - MemoryPinTool and MemoryUnpinTool only require db as constructor dependency
  - Pin updates tier to WARM if currently COLD or ARCHIVE (pinned memories should be accessible)
  - Audit entries include both pinned flag and tier in old_value/new_value for pin action
  - Already-pinned or not-pinned states throw errors with helpful messages
  - tierUpdated flag in result indicates if tier was changed during pinning
---

## 2026-01-31 - US-014
- What was implemented: Created MemoryRecallTool class for searching and retrieving memories with hybrid search
- Files changed:
  - extensions/memory-tiered/tools/memory_recall.ts (new)
- **Learnings for future iterations:**
  - MemoryRecallTool takes db, embeddingProvider, vectorHelper, and optional scorer as constructor dependencies
  - execute() method returns MemoryRecallResult with content array and memories array
  - Uses vectorHelper.hybridSearch() combining FTS and vector similarity
  - After hybrid search, fetches full memory records with fetchMemories() for scoring and filtering
  - Filtering: tier filter, includeArchive (default false), includeForgotten (default false)
  - Applies MemoryScorer.score() with the vectorScore from hybrid results as the similarity
  - Updates access stats (use_count++, last_accessed_at, use_days) for returned memories only
  - RecalledMemory includes forgotten flag (maps from do_not_inject boolean)
---

## 2026-01-31 - US-013
- What was implemented: Created MemoryStoreTool class for storing new memories with duplicate detection
- Files changed:
  - extensions/memory-tiered/tools/memory_store.ts (new)
- **Learnings for future iterations:**
  - MemoryStoreTool takes db, embeddingProvider, and vectorHelper as constructor dependencies
  - execute() method returns MemoryStoreResult with content array and details object
  - Duplicate detection uses vectorHelper.vectorSearch() with 0.95 similarity threshold
  - If duplicate found, returns existing memory details with isDuplicate: true
  - Memory creation stores embedding immediately after inserting memory record
  - use_days initialized with today's date as JSON array; last_accessed_at set to creation time
  - parseMemoryType() defaults to factual when type not specified or invalid
---

## 2026-01-31 - US-011
- What was implemented: Created TierBudgetAllocator class for tier-based injection slot allocation
- Files changed:
  - extensions/memory-tiered/core/injection.ts (new)
- **Learnings for future iterations:**
  - TierBudgetAllocator composes with MemoryScorer (accepts optional scorer in constructor)
  - allocate() filters out do_not_inject and ARCHIVE memories before processing
  - Pinned memories are separated from tier-based allocation (they have their own 25% budget)
  - Slots per tier calculated with Math.floor to avoid exceeding maxItems
  - Final result sorted by score regardless of tier (best memories appear first)
  - AllocationResult includes breakdown for debugging and the excludedCount for transparency
  - Default budgets sum to 100%: 25% + 45% + 25% + 5% = 100%
---

## 2026-01-31 - US-010
- What was implemented: Created MemoryScorer class with composite scoring formula
- Files changed:
  - extensions/memory-tiered/core/scorer.ts (new)
- **Learnings for future iterations:**
  - Composite score formula: w_sim * similarity + w_rec * exp(-age/halflife) + w_freq * log(1+use_count)
  - effective_age = now - max(created_at, last_accessed_at) in days
  - Half-lives exported as HALF_LIVES constant for reuse in other modules
  - Pinned memories: recencyValue = 1 (infinite half-life)
  - COLD tier: recencyValue *= 0.5 (additional penalty)
  - ARCHIVE tier: totalScore = 0 (never injected)
  - Frequency normalized by log(101)≈4.6 to keep component in 0-1 range
  - scoreWithBreakdown() returns all components for explainability (useful for memory_explain tool)
---

## 2026-01-31 - US-009
- What was implemented: Added hybridSearch function to VectorHelper combining FTS and vector search
- Files changed:
  - extensions/memory-tiered/db/vectors.ts (updated)
- **Learnings for future iterations:**
  - hybridSearch imports FTS5Helper and can accept it via constructor or setFtsHelper() for sharing
  - Hybrid search fetches 3x candidates (min 30) from both sources, then merges
  - BM25 scores normalized to 0-1 by dividing by max score (avoids negative handling)
  - Default weights: vector (0.7), text (0.3) - vector similarity has higher weight
  - Combined score = vectorWeight * vectorScore + textWeight * textScore
  - Results include both component scores for explainability
  - Deduplication via Set of IDs from union of both result sets
---

## 2026-01-31 - US-008
- What was implemented: Created VectorHelper for sqlite-vec vector search with cosine fallback
- Files changed:
  - extensions/memory-tiered/db/vectors.ts (new)
- **Learnings for future iterations:**
  - sqlite-vec extension loaded via db.loadExtension(); try multiple paths (vec0, sqlite-vec)
  - vec0 virtual table: CREATE VIRTUAL TABLE name USING vec0(id TEXT PK, embedding FLOAT[N])
  - sqlite-vec provides vec_distance_cosine() function; convert to similarity with 1 - distance
  - For fallback, store embeddings as Buffers from Float32Array
  - Buffer.from(new Float32Array(embedding).buffer) creates blob for storage
  - VectorSearchResult includes id, text, similarity (0-1 score)
  - Fallback loads all embeddings and computes similarity in-memory (O(n) for each search)
---

## 2026-01-31 - US-007
- What was implemented: Created OpenAIEmbeddingProvider for cloud-based embeddings via OpenAI API
- Files changed:
  - extensions/memory-tiered/embeddings/openai.ts (new)
- **Learnings for future iterations:**
  - OpenAI embeddings API endpoint: https://api.openai.com/v1/embeddings
  - API key required in config; validated in constructor with actionable error message
  - Default model is text-embedding-3-small with 1536 dimensions
  - embedBatch uses the same endpoint with array input for efficiency
  - Response data may be unordered; sort by index before returning
  - Network errors detected via TypeError from fetch; provide connectivity guidance
---

## 2026-01-31 - US-006
- What was implemented: Created LocalEmbeddingProvider using @xenova/transformers for offline embeddings
- Files changed:
  - extensions/memory-tiered/embeddings/local.ts (new)
  - extensions/memory-tiered/package.json (added @xenova/transformers dependency)
  - extensions/memory-tiered/package-lock.json (updated)
- **Learnings for future iterations:**
  - @xenova/transformers includes TypeScript types; no separate @types package needed
  - Use dynamic import for @xenova/transformers to avoid loading at module initialization
  - pipeline("feature-extraction", modelPath) creates embedding pipeline
  - Output needs { pooling: "mean", normalize: true } for sentence embeddings
  - Batch embeddings return flat Float32Array; slice by dimensions for each input
  - Model dimensions map: MODEL_DIMENSIONS[modelPath] for known models
  - Error messages should include actionable guidance (e.g., npm install suggestion)
---

## 2026-01-31 - US-005
- What was implemented: Created EmbeddingProvider interface for embedding abstraction
- Files changed:
  - extensions/memory-tiered/embeddings/provider.ts (new)
- **Learnings for future iterations:**
  - The EmbeddingProvider interface supports both single and batch embedding operations
  - getDimensions() returns the vector size (e.g., 384 for MiniLM, 1536 for OpenAI)
  - getModelName() returns the model identifier for logging/debugging
  - Implementations will need to cache loaded models for performance (US-006)
---

## 2026-01-31 - US-004
- What was implemented: Created FTS5 full-text search integration with BM25 ranking
- Files changed:
  - extensions/memory-tiered/db/fts.ts (new)
- **Learnings for future iterations:**
  - FTS5 virtual table uses `content='memories', content_rowid='rowid'` for external content
  - Triggers sync INSERT/UPDATE/DELETE from memories table to FTS index
  - BM25 function returns negative scores; negate them for intuitive "higher is better" ranking
  - FTS5 query syntax can cause errors with special chars; wrap in quotes as fallback
  - Prepared statements should be cached for repeated queries (searchStmt pattern)
  - rebuildIndex() is useful after bulk imports or corruption recovery
---

## 2026-01-31 - US-003
- What was implemented: Created SQLite database wrapper with full schema initialization
- Files changed:
  - extensions/memory-tiered/db/sqlite.ts (new)
  - extensions/memory-tiered/package.json (added better-sqlite3)
  - extensions/memory-tiered/package-lock.json (new)
- **Learnings for future iterations:**
  - better-sqlite3 requires native compilation; works best with Node.js 18+
  - SQLite CHECK constraints enforce tier values at DB level: CHECK (tier IN ('HOT', 'WARM', 'COLD', 'ARCHIVE'))
  - Schema includes nullable columns entity_refs and meta_type for Phase 2 extensions
  - The Database class initializes schema in constructor - call once per db path
  - WAL mode provides better concurrency for read-heavy workloads
---

## 2026-01-31 - US-002
- What was implemented: Created core/types.ts with all type definitions for the tiered memory system
- Files changed:
  - extensions/memory-tiered/core/types.ts (new)
- **Learnings for future iterations:**
  - The project uses TypeScript with strict mode and NodeNext module resolution
  - Tier enum values should match the CHECK constraint in the future SQLite schema
  - MemoryType affects decay half-life: procedural (180d), factual (90d), project (45d), episodic (10d)
  - use_days is a string[] (JSON array) stored as string in SQLite for tracking distinct access days
---

## 2026-01-31 - US-012
- What was implemented: Created Zod-based configuration schema with UI hints for OpenClaw
- Files changed:
  - extensions/memory-tiered/config.ts (new)
  - extensions/memory-tiered/package.json (added zod dependency)
  - extensions/memory-tiered/package-lock.json (updated)
- **Learnings for future iterations:**
  - Zod's .default({}) for nested objects requires full default values; use .optional() instead and provide a resolveConfig() function to apply defaults
  - ResolvedConfig interface represents the fully-resolved config with all defaults applied
  - DEFAULTS constant centralizes all default values for easy reference
  - uiHints uses nested fields structure matching the schema hierarchy
  - dependsOn in uiHints indicates conditional visibility (e.g., apiKey depends on provider value)
  - configSchema export bundles schema, parse, safeParse, resolve, and uiHints for plugin registration
---

## 2026-01-31 - US-015
- What was implemented: Created MemoryForgetTool class for soft/hard memory deletion with audit logging
- Files changed:
  - extensions/memory-tiered/tools/memory_forget.ts (new)
- **Learnings for future iterations:**
  - MemoryForgetTool supports both query-based and ID-based lookup for flexibility
  - UUID validation uses regex: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  - Soft forget sets do_not_inject = 1; hard delete removes from memories table entirely
  - VectorHelper.deleteEmbedding() cleans up vector storage on hard delete
  - Audit entries use JSON.stringify for old_value/new_value to preserve structure
  - Hard delete audit logs "hard_delete" as old_value since memory no longer exists
  - MemoryForgetResult includes restorable flag (true for soft forget, false for hard delete)
  - Already-forgotten memories throw error to prevent double-forget; suggest hard=true
---

## 2026-01-31 - US-016
- What was implemented: Created MemoryRestoreTool class for restoring forgotten memories
- Files changed:
  - extensions/memory-tiered/tools/memory_restore.ts (new)
- **Learnings for future iterations:**
  - MemoryRestoreTool only requires db as constructor dependency (no embedding/vector needed)
  - execute() takes memoryId (required) and validates UUID format
  - Restoring sets do_not_inject = 0 (was 1 when forgotten)
  - Creates audit entry with action='restore' and old/new JSON values for do_not_inject
  - Errors: "Memory not found: {id}" and "Memory is not forgotten: {id}"
  - MemoryRestoreResult includes tier in details (useful for UI feedback)
  - execute() is async to match pattern of other tools, though operations are synchronous
---
