## Codebase Patterns
- Use TypeScript enums with string values for database column values (e.g., Tier.HOT = "HOT")
- Use ISO 8601 date strings for all timestamp fields
- Use JSDoc comments on interfaces and enums to document purpose and half-lives
- JSON arrays stored as strings in SQLite (e.g., use_days)

- Use better-sqlite3 for synchronous SQLite operations with TypeScript
- Enable WAL mode (journal_mode = WAL) for concurrency
- Use INTEGER for boolean columns (do_not_inject, pinned) with 0/1 values
- Foreign key constraints supported but need PRAGMA foreign_keys = ON for enforcement

- FTS5 uses content='' with content_rowid for external content tables (sync via triggers)
- BM25 scores in FTS5 are negative; negate for intuitive ranking (higher = more relevant)
- Cache prepared statements for performance (e.g., searchStmt in FTS5Helper)
- Handle FTS5 query syntax errors by falling back to phrase search with escaped quotes

- @xenova/transformers provides fully offline embedding inference via ONNX runtime
- Cache model pipelines after first load (use initPromise pattern to prevent concurrent initialization)
- Use mean pooling + normalization for sentence embeddings
- Common model dimensions: MiniLM = 384, mpnet/gte-base/e5-base = 768

- OpenAI embedding models: text-embedding-3-small (1536), text-embedding-3-large (3072), text-embedding-ada-002 (1536)
- Use native fetch() for API calls (Node 18+); no additional HTTP library needed
- OpenAI embeddings API may return results out of order; sort by index field
- Provide specific error guidance based on HTTP status (401=auth, 429=rate limit, 400=bad input)

- sqlite-vec uses vec0 virtual table with FLOAT[N] column type for embeddings
- When sqlite-vec unavailable, store embeddings as BLOBs (Float32Array buffer)
- Cosine similarity: dot(a,b) / (||a|| * ||b||), clamp result to [0,1] for floating point safety
- Convert Buffer to Float32Array using buffer.buffer, buffer.byteOffset, buffer.byteLength/4

- MemoryScorer uses exp(-age/halflife) for recency decay; pinned memories bypass this with value 1.0
- Frequency component uses log(1+use_count) normalized by log(101)≈4.6 for reasonable scaling
- scoreWithBreakdown() provides transparency for memory_explain tool implementation

- TierBudgetAllocator allocates slots by tier: pinned (25%), HOT (45%), WARM (25%), COLD (5%)
- Use Math.floor for slot calculation to avoid over-allocation; final truncation ensures maxItems respected
- AllocationResult includes breakdown counts for each bucket and excludedCount for filtered memories
- ScoredMemory pairs Memory with score for transparent ranking

- Zod schemas: use .optional() for nested objects, then resolveConfig() applies defaults via ?? operator
- configSchema exports: { schema, parse, safeParse, resolve, uiHints } for OpenClaw plugin registration
- uiHints structure matches schema hierarchy with label, description, type fields for UI generation

- Tools use MemoryStoreResult with { content: [...], details: {...} } format for agent responses
- DUPLICATE_THRESHOLD = 0.95 for detecting similar memories via vector similarity
- Store use_days as JSON.stringify([today]) on initial creation; today = ISO date YYYY-MM-DD
- Validate and clamp importance to [0.0, 1.0] range
- MemoryRecallTool returns { content: [...], memories: [...] } format for search results
- Hybrid search fetches 3x candidates (min 30) for filtering; final limit applied after scoring
- updateAccessStats increments use_count and appends today to use_days if not already present

- Context tools use ACTIVE_CONTEXT_ID = "active" constant for the single context row
- MemorySetContextTool.getContext() implements lazy TTL expiry check; returns null and cleans up if expired
- TTL stored as seconds in DB (ttl_seconds), but tool accepts ttlHours for UX convenience
- Context expiry calculated as: createdAt.getTime() + ttl_seconds * 1000

- AutoCaptureHook captures important text from agent responses into memories
- Memory type detection uses regex patterns: procedural, project, episodic, factual (default)
- Importance scoring factors: pattern matches, code snippets (`...`), importance keywords, list structure
- DUPLICATE_THRESHOLD = 0.95 applies to auto-capture (same as memory_store tool)

- AutoRecallHook.extractKeyTerms() removes stop words and short tokens for focused search
- Format injected memories as XML: <relevant-memories><current-context>...</current-context><memory>...</memory></relevant-memories>
- Hooks receive ResolvedConfig; createAutoRecallHook() factory maps config to AutoRecallConfig

- Plugin entry point exports default plugin object with id, name, kind, configSchema, and register()
- register() initializes database, FTS helper, embedding provider, vector helper, then registers tools and hooks
- createEmbeddingProvider() handles auto/local/openai provider selection with fallback logic
- Tool registration uses api.registerTool() with name, description, parameters, and execute function
- Hook registration uses api.on("before_agent_start"|"agent_end", handler) for lifecycle events

---

## 2026-01-31 - US-022
- What was implemented: Created plugin entry point with default export, tool registration, and hook registration
- Files changed:
  - extensions/memory-tiered/index.ts (updated)
- **Learnings for future iterations:**
  - Plugin object requires id, name, kind, configSchema, and async register(api, rawConfig) function
  - PluginApi interface provides registerTool(name, definition) and on(event, handler) methods
  - ToolDefinition requires name, description, parameters (JSON Schema), and async execute(input) function
  - Database directory should be created with mkdirSync(dbDir, { recursive: true }) before opening DB
  - FTS5Helper should be shared with VectorHelper via constructor parameter for efficient hybrid search
  - createEmbeddingProvider() supports "auto", "local", "openai", "gemini" (gemini not yet implemented)
  - Auto mode prefers local provider but falls back to OpenAI if API key available and local fails
  - Tool parameter schemas follow JSON Schema format with type, properties, required fields
  - Hook handlers receive unknown type and must validate before processing (typeof prompt !== "string")
  - All 9 tools registered: memory_store, memory_recall, memory_forget, memory_restore, memory_pin, memory_unpin, memory_explain, memory_set_context, memory_clear_context
  - Both hooks registered: before_agent_start (auto-recall), agent_end (auto-capture)
---

## 2026-01-31 - US-021
- What was implemented: Created AutoCaptureHook class for agent_end hook with automatic memory capture
- Files changed:
  - extensions/memory-tiered/hooks/auto_capture.ts (new)
- **Learnings for future iterations:**
  - AutoCaptureHook takes db, embeddingProvider, vectorHelper, and optional config as constructor dependencies
  - execute(response) extracts capturable candidates, checks duplicates, and stores as memories
  - extractCapturableCandidates() splits by paragraphs, filters by length (10-500 chars), extracts sentences if too long
  - detectMemoryType() uses MEMORY_TYPE_PATTERNS with regex matching for procedural/project/episodic/factual
  - Importance score includes: pattern match ratio, length ratio, code snippets, importance keywords, list structure
  - maxCapturesPerConversation = 3 by default; processes top-scored candidates first
  - Duplicate detection: isDuplicate() checks vectorSearch for similarity >= 0.95
  - All captured memories stored as tier='HOT', source='auto-capture', importance=0.5
  - createAutoCaptureHook() factory function maps ResolvedConfig to AutoCaptureConfig
---

## 2026-01-31 - US-020
- What was implemented: Created AutoRecallHook class for before_agent_start hook with automatic memory injection
- Files changed:
  - extensions/memory-tiered/hooks/auto_recall.ts (new)
- **Learnings for future iterations:**
  - AutoRecallHook takes db, embeddingProvider, vectorHelper, and optional config as constructor dependencies
  - execute(prompt) extracts key terms, runs hybrid search, applies tier budget allocation, and formats XML
  - extractKeyTerms() filters common stop words and short tokens, returns top 20 unique terms
  - Uses TierBudgetAllocator to respect tier budgets (pinned 25%, HOT 45%, WARM 25%, COLD 5%)
  - Budgets in config are percentages (0-100); convert to decimals (0-1) when passing to TierBudgetAllocator
  - Current context always included first in XML output via MemorySetContextTool.getContext()
  - Returns { prependContext, memoriesInjected, contextIncluded } for hook result
  - createAutoRecallHook() factory function maps ResolvedConfig to AutoRecallConfig
  - escapeXml() handles &, <, >, ", ' characters for safe XML embedding
---

## 2026-01-31 - US-019
- What was implemented: Created MemorySetContextTool and MemoryClearContextTool for managing active task context
- Files changed:
  - extensions/memory-tiered/tools/memory_set_context.ts (new)
  - extensions/memory-tiered/tools/memory_clear_context.ts (new)
- **Learnings for future iterations:**
  - MemorySetContextTool and MemoryClearContextTool only require db as constructor dependency
  - Set context uses INSERT OR REPLACE for upsert behavior on id='active'
  - Clear context returns different messages based on whether context existed
  - MemorySetContextResult includes expires_at timestamp for UI feedback
  - getContext() method on MemorySetContextTool can be reused by hooks for auto-recall
  - Lazy TTL check cleans up expired context on retrieval rather than via scheduled job
---

## 2026-01-31 - US-018
- What was implemented: Created MemoryExplainTool class for explaining memory scoring and injection eligibility
- Files changed:
  - extensions/memory-tiered/tools/memory_explain.ts (new)
- **Learnings for future iterations:**
  - MemoryExplainTool takes db, optional embeddingProvider, optional vectorHelper, and optional scorer
  - execute() returns MemoryExplainResult with content array and details object
  - Scoring explanation includes similarityValue (raw 0-1), weighted components, and totalScore
  - Injection eligibility includes: eligible (bool), reason (string), isPinned, isForgotten, tier
  - Uses vectorHelper.vectorSearch() with limit 100 to find memory's similarity for query
  - formatExplanationText() builds human-readable multi-line explanation string
  - Imports HALF_LIVES from scorer.ts for displaying memory type half-life in output
---

## 2026-01-31 - US-017
- What was implemented: Created MemoryPinTool and MemoryUnpinTool classes for pinning/unpinning memories
- Files changed:
  - extensions/memory-tiered/tools/memory_pin.ts (new)
  - extensions/memory-tiered/tools/memory_unpin.ts (new)
- **Learnings for future iterations:**
  - MemoryPinTool and MemoryUnpinTool only require db as constructor dependency
  - Pin updates tier to WARM if currently COLD or ARCHIVE (pinned memories should be accessible)
  - Audit entries include both pinned flag and tier in old_value/new_value for pin action
  - Already-pinned or not-pinned states throw errors with helpful messages
  - tierUpdated flag in result indicates if tier was changed during pinning
---

## 2026-01-31 - US-014
- What was implemented: Created MemoryRecallTool class for searching and retrieving memories with hybrid search
- Files changed:
  - extensions/memory-tiered/tools/memory_recall.ts (new)
- **Learnings for future iterations:**
  - MemoryRecallTool takes db, embeddingProvider, vectorHelper, and optional scorer as constructor dependencies
  - execute() method returns MemoryRecallResult with content array and memories array
  - Uses vectorHelper.hybridSearch() combining FTS and vector similarity
  - After hybrid search, fetches full memory records with fetchMemories() for scoring and filtering
  - Filtering: tier filter, includeArchive (default false), includeForgotten (default false)
  - Applies MemoryScorer.score() with the vectorScore from hybrid results as the similarity
  - Updates access stats (use_count++, last_accessed_at, use_days) for returned memories only
  - RecalledMemory includes forgotten flag (maps from do_not_inject boolean)
---

## 2026-01-31 - US-013
- What was implemented: Created MemoryStoreTool class for storing new memories with duplicate detection
- Files changed:
  - extensions/memory-tiered/tools/memory_store.ts (new)
- **Learnings for future iterations:**
  - MemoryStoreTool takes db, embeddingProvider, and vectorHelper as constructor dependencies
  - execute() method returns MemoryStoreResult with content array and details object
  - Duplicate detection uses vectorHelper.vectorSearch() with 0.95 similarity threshold
  - If duplicate found, returns existing memory details with isDuplicate: true
  - Memory creation stores embedding immediately after inserting memory record
  - use_days initialized with today's date as JSON array; last_accessed_at set to creation time
  - parseMemoryType() defaults to factual when type not specified or invalid
---

## 2026-01-31 - US-011
- What was implemented: Created TierBudgetAllocator class for tier-based injection slot allocation
- Files changed:
  - extensions/memory-tiered/core/injection.ts (new)
- **Learnings for future iterations:**
  - TierBudgetAllocator composes with MemoryScorer (accepts optional scorer in constructor)
  - allocate() filters out do_not_inject and ARCHIVE memories before processing
  - Pinned memories are separated from tier-based allocation (they have their own 25% budget)
  - Slots per tier calculated with Math.floor to avoid exceeding maxItems
  - Final result sorted by score regardless of tier (best memories appear first)
  - AllocationResult includes breakdown for debugging and the excludedCount for transparency
  - Default budgets sum to 100%: 25% + 45% + 25% + 5% = 100%
---

## 2026-01-31 - US-010
- What was implemented: Created MemoryScorer class with composite scoring formula
- Files changed:
  - extensions/memory-tiered/core/scorer.ts (new)
- **Learnings for future iterations:**
  - Composite score formula: w_sim * similarity + w_rec * exp(-age/halflife) + w_freq * log(1+use_count)
  - effective_age = now - max(created_at, last_accessed_at) in days
  - Half-lives exported as HALF_LIVES constant for reuse in other modules
  - Pinned memories: recencyValue = 1 (infinite half-life)
  - COLD tier: recencyValue *= 0.5 (additional penalty)
  - ARCHIVE tier: totalScore = 0 (never injected)
  - Frequency normalized by log(101)≈4.6 to keep component in 0-1 range
  - scoreWithBreakdown() returns all components for explainability (useful for memory_explain tool)
---

## 2026-01-31 - US-009
- What was implemented: Added hybridSearch function to VectorHelper combining FTS and vector search
- Files changed:
  - extensions/memory-tiered/db/vectors.ts (updated)
- **Learnings for future iterations:**
  - hybridSearch imports FTS5Helper and can accept it via constructor or setFtsHelper() for sharing
  - Hybrid search fetches 3x candidates (min 30) from both sources, then merges
  - BM25 scores normalized to 0-1 by dividing by max score (avoids negative handling)
  - Default weights: vector (0.7), text (0.3) - vector similarity has higher weight
  - Combined score = vectorWeight * vectorScore + textWeight * textScore
  - Results include both component scores for explainability
  - Deduplication via Set of IDs from union of both result sets
---

## 2026-01-31 - US-008
- What was implemented: Created VectorHelper for sqlite-vec vector search with cosine fallback
- Files changed:
  - extensions/memory-tiered/db/vectors.ts (new)
- **Learnings for future iterations:**
  - sqlite-vec extension loaded via db.loadExtension(); try multiple paths (vec0, sqlite-vec)
  - vec0 virtual table: CREATE VIRTUAL TABLE name USING vec0(id TEXT PK, embedding FLOAT[N])
  - sqlite-vec provides vec_distance_cosine() function; convert to similarity with 1 - distance
  - For fallback, store embeddings as Buffers from Float32Array
  - Buffer.from(new Float32Array(embedding).buffer) creates blob for storage
  - VectorSearchResult includes id, text, similarity (0-1 score)
  - Fallback loads all embeddings and computes similarity in-memory (O(n) for each search)
---

## 2026-01-31 - US-007
- What was implemented: Created OpenAIEmbeddingProvider for cloud-based embeddings via OpenAI API
- Files changed:
  - extensions/memory-tiered/embeddings/openai.ts (new)
- **Learnings for future iterations:**
  - OpenAI embeddings API endpoint: https://api.openai.com/v1/embeddings
  - API key required in config; validated in constructor with actionable error message
  - Default model is text-embedding-3-small with 1536 dimensions
  - embedBatch uses the same endpoint with array input for efficiency
  - Response data may be unordered; sort by index before returning
  - Network errors detected via TypeError from fetch; provide connectivity guidance
---

## 2026-01-31 - US-006
- What was implemented: Created LocalEmbeddingProvider using @xenova/transformers for offline embeddings
- Files changed:
  - extensions/memory-tiered/embeddings/local.ts (new)
  - extensions/memory-tiered/package.json (added @xenova/transformers dependency)
  - extensions/memory-tiered/package-lock.json (updated)
- **Learnings for future iterations:**
  - @xenova/transformers includes TypeScript types; no separate @types package needed
  - Use dynamic import for @xenova/transformers to avoid loading at module initialization
  - pipeline("feature-extraction", modelPath) creates embedding pipeline
  - Output needs { pooling: "mean", normalize: true } for sentence embeddings
  - Batch embeddings return flat Float32Array; slice by dimensions for each input
  - Model dimensions map: MODEL_DIMENSIONS[modelPath] for known models
  - Error messages should include actionable guidance (e.g., npm install suggestion)
---

## 2026-01-31 - US-005
- What was implemented: Created EmbeddingProvider interface for embedding abstraction
- Files changed:
  - extensions/memory-tiered/embeddings/provider.ts (new)
- **Learnings for future iterations:**
  - The EmbeddingProvider interface supports both single and batch embedding operations
  - getDimensions() returns the vector size (e.g., 384 for MiniLM, 1536 for OpenAI)
  - getModelName() returns the model identifier for logging/debugging
  - Implementations will need to cache loaded models for performance (US-006)
---

## 2026-01-31 - US-004
- What was implemented: Created FTS5 full-text search integration with BM25 ranking
- Files changed:
  - extensions/memory-tiered/db/fts.ts (new)
- **Learnings for future iterations:**
  - FTS5 virtual table uses `content='memories', content_rowid='rowid'` for external content
  - Triggers sync INSERT/UPDATE/DELETE from memories table to FTS index
  - BM25 function returns negative scores; negate them for intuitive "higher is better" ranking
  - FTS5 query syntax can cause errors with special chars; wrap in quotes as fallback
  - Prepared statements should be cached for repeated queries (searchStmt pattern)
  - rebuildIndex() is useful after bulk imports or corruption recovery
---

## 2026-01-31 - US-003
- What was implemented: Created SQLite database wrapper with full schema initialization
- Files changed:
  - extensions/memory-tiered/db/sqlite.ts (new)
  - extensions/memory-tiered/package.json (added better-sqlite3)
  - extensions/memory-tiered/package-lock.json (new)
- **Learnings for future iterations:**
  - better-sqlite3 requires native compilation; works best with Node.js 18+
  - SQLite CHECK constraints enforce tier values at DB level: CHECK (tier IN ('HOT', 'WARM', 'COLD', 'ARCHIVE'))
  - Schema includes nullable columns entity_refs and meta_type for Phase 2 extensions
  - The Database class initializes schema in constructor - call once per db path
  - WAL mode provides better concurrency for read-heavy workloads
---

## 2026-01-31 - US-002
- What was implemented: Created core/types.ts with all type definitions for the tiered memory system
- Files changed:
  - extensions/memory-tiered/core/types.ts (new)
- **Learnings for future iterations:**
  - The project uses TypeScript with strict mode and NodeNext module resolution
  - Tier enum values should match the CHECK constraint in the future SQLite schema
  - MemoryType affects decay half-life: procedural (180d), factual (90d), project (45d), episodic (10d)
  - use_days is a string[] (JSON array) stored as string in SQLite for tracking distinct access days
---

## 2026-01-31 - US-012
- What was implemented: Created Zod-based configuration schema with UI hints for OpenClaw
- Files changed:
  - extensions/memory-tiered/config.ts (new)
  - extensions/memory-tiered/package.json (added zod dependency)
  - extensions/memory-tiered/package-lock.json (updated)
- **Learnings for future iterations:**
  - Zod's .default({}) for nested objects requires full default values; use .optional() instead and provide a resolveConfig() function to apply defaults
  - ResolvedConfig interface represents the fully-resolved config with all defaults applied
  - DEFAULTS constant centralizes all default values for easy reference
  - uiHints uses nested fields structure matching the schema hierarchy
  - dependsOn in uiHints indicates conditional visibility (e.g., apiKey depends on provider value)
  - configSchema export bundles schema, parse, safeParse, resolve, and uiHints for plugin registration
---

## 2026-01-31 - US-015
- What was implemented: Created MemoryForgetTool class for soft/hard memory deletion with audit logging
- Files changed:
  - extensions/memory-tiered/tools/memory_forget.ts (new)
- **Learnings for future iterations:**
  - MemoryForgetTool supports both query-based and ID-based lookup for flexibility
  - UUID validation uses regex: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  - Soft forget sets do_not_inject = 1; hard delete removes from memories table entirely
  - VectorHelper.deleteEmbedding() cleans up vector storage on hard delete
  - Audit entries use JSON.stringify for old_value/new_value to preserve structure
  - Hard delete audit logs "hard_delete" as old_value since memory no longer exists
  - MemoryForgetResult includes restorable flag (true for soft forget, false for hard delete)
  - Already-forgotten memories throw error to prevent double-forget; suggest hard=true
---

## 2026-01-31 - US-016
- What was implemented: Created MemoryRestoreTool class for restoring forgotten memories
- Files changed:
  - extensions/memory-tiered/tools/memory_restore.ts (new)
- **Learnings for future iterations:**
  - MemoryRestoreTool only requires db as constructor dependency (no embedding/vector needed)
  - execute() takes memoryId (required) and validates UUID format
  - Restoring sets do_not_inject = 0 (was 1 when forgotten)
  - Creates audit entry with action='restore' and old/new JSON values for do_not_inject
  - Errors: "Memory not found: {id}" and "Memory is not forgotten: {id}"
  - MemoryRestoreResult includes tier in details (useful for UI feedback)
  - execute() is async to match pattern of other tools, though operations are synchronous
---

## 2026-01-31 - US-023
- What was implemented: Created MemorySearchCommand class for CLI memory search functionality
- Files changed:
  - extensions/memory-tiered/cli/search.ts (new)
- **Learnings for future iterations:**
  - CLI commands live in cli/ directory alongside tools/ and hooks/
  - MemorySearchCommand takes same dependencies as MemoryRecallTool: db, embeddingProvider, vectorHelper, optional scorer
  - SearchOptions interface defines CLI flags: deep, tier, limit, json, explain
  - truncateText() helper converts multiline text to single line and limits to 80 chars with ellipsis
  - formatResult() and formatTextOutput() provide human-readable CLI output
  - JSON output uses JSON.stringify(result, null, 2) for pretty-printing
  - --explain flag reuses ScoreBreakdown from scorer.scoreWithBreakdown() for consistency with memory_explain tool
  - SearchCommandResult includes metadata: query, count, deep flag, tierFilter for context
  - Results include [PINNED] and [FORGOTTEN] tags in text output for visual status indicators
---

## 2026-01-31 - US-024
- What was implemented: Created MemoryListCommand class for CLI memory listing functionality
- Files changed:
  - extensions/memory-tiered/cli/list.ts (new)
- **Learnings for future iterations:**
  - MemoryListCommand only requires db as constructor dependency (no embedding/vector needed for listing)
  - Default behavior (no filters) shows tier count summary with bar chart visualization
  - Filtered mode triggered when any of --tier, --forgotten, or --pinned specified
  - executeSummary() uses GROUP BY tier with CASE-based ordering for consistent tier order
  - executeFiltered() builds dynamic WHERE clause from options
  - ListItem contains simplified memory info suitable for display (no scoring needed)
  - Sort field maps directly to column; all sorts use DESC (most recent/highest first)
  - formatTierCounts() creates ASCII bar chart with percentage breakdown
  - TierCount array always includes all 4 tiers even if count is 0 (consistent display)
  - ListCommandResult has optional tierCounts and items; presence indicates summary vs filtered mode
---

## 2026-01-31 - US-025
- What was implemented: Created MemoryStatsCommand class for CLI memory statistics display
- Files changed:
  - extensions/memory-tiered/cli/stats.ts (new)
- **Learnings for future iterations:**
  - MemoryStatsCommand requires db, dbPath, embeddingProvider, and ResolvedConfig as constructor dependencies
  - StatsOptions interface is simple: just `json?: boolean` for output format
  - formatBytes() helper converts bytes to human-readable KB/MB/GB with appropriate precision
  - Tier stats and memory type stats both include percentage calculations for visual context
  - Context status has three states: "active", "expired", "none" - detect via DB query + TTL check
  - EmbeddingInfo includes provider (from config), model (from provider.getModelName()), dimensions (from provider.getDimensions())
  - Last decay run timestamp stored in a `meta` table with key='last_decay_run'; check if table exists first
  - formatTextOutput() builds multi-section output with headers, bar charts, and labeled fields
  - ASCII bar chart uses █ character with Math.ceil(percentage / 5) for consistent scaling
---

## 2026-01-31 - US-026
- What was implemented: Created CLI commands for forget, restore, pin, and unpin memory management
- Files changed:
  - extensions/memory-tiered/cli/forget.ts (new)
  - extensions/memory-tiered/cli/restore.ts (new)
  - extensions/memory-tiered/cli/pin.ts (new)
  - extensions/memory-tiered/cli/unpin.ts (new)
- **Learnings for future iterations:**
  - CLI commands wrap tool classes (e.g., MemoryForgetCommand uses MemoryForgetTool internally)
  - ForgetCommand supports both UUID and query-based lookup via UUID_REGEX detection
  - Hard delete requires --confirm flag for safety; throws error if not confirmed
  - ForgetOptions, RestoreOptions, PinOptions, UnpinOptions follow same pattern: json optional flag
  - CommandResult interfaces include action, memoryId, text, and success message
  - formatTextOutput() creates consistent multi-line output with headers and labeled fields
  - All commands validate input before delegating to underlying tools
  - RestoreCommand, PinCommand, UnpinCommand only require db (no embedding/vector dependencies)
---

## 2026-01-31 - US-027
- What was implemented: Created MemoryExplainCommand class for CLI memory explanation functionality
- Files changed:
  - extensions/memory-tiered/cli/explain.ts (new)
- **Learnings for future iterations:**
  - MemoryExplainCommand wraps MemoryExplainTool for CLI usage
  - ExplainOptions interface has query (optional for similarity) and json (optional for output format)
  - ExplainCommandResult includes all details from MemoryExplanationDetails plus queryUsed field
  - formatTextOutput() creates multi-section display: ID, tier, type, text, timestamps, usage stats, scoring, injection
  - Scoring section shows both raw and weighted values for transparency
  - useDays display shows first 5 days with "(+N more)" suffix for longer lists
  - Query displayed in scoring section when provided (shows what was used for similarity)
  - Reuses UUID_REGEX for ID validation consistency across CLI commands
---

## 2026-01-31 - US-028
- What was implemented: Created MemorySetContextCommand and MemoryClearContextCommand for CLI context management
- Files changed:
  - extensions/memory-tiered/cli/context.ts (new)
- **Learnings for future iterations:**
  - CLI context commands wrap MemorySetContextTool and MemoryClearContextTool for CLI usage
  - SetContextOptions has ttl (number of hours) and json (output format) options
  - ClearContextOptions has only json (output format) option
  - SetContextCommandResult includes ttlHours (calculated from ttlSeconds/3600) for human-friendly display
  - ClearContextCommandResult includes previousText (truncated) when context was actually cleared
  - truncateText() helper converts multiline text to single line and limits to 80 chars with ellipsis
  - Both commands validate input before delegating to underlying tools
  - formatSetContextOutput() shows text, TTL, and expiry timestamp
  - formatClearContextOutput() shows previous text when cleared, or simple message otherwise
---

## 2026-01-31 - US-029
- What was implemented: Updated plugin entry point to register all CLI commands via api.registerCli()
- Files changed:
  - extensions/memory-tiered/index.ts (updated)
- **Learnings for future iterations:**
  - PluginApi.registerCli() takes parentCommand, description, subcommands[], and options object
  - CliCommandDefinition has name, description, arguments[] (optional), options[] (optional), and execute function
  - Arguments have name, description, and required fields; Options have flags and description
  - Execute function receives (args: Record<string, unknown>, options: Record<string, unknown>) => Promise<string>
  - All 10 subcommands registered: search, list, stats, forget, restore, pin, unpin, explain, set-context, clear-context
  - CLI command instances created after hooks but before registerCli() call
  - CliRegistrationOptions includes commands array for command namespace registration
  - Options with values use format "--flag <value>" (e.g., "--tier <tier>")
  - Boolean options use simple format "--flag" (e.g., "--deep", "--json")
  - Default values can be specified in options definition (e.g., default: 10 for --limit)
---

## 2026-01-31 - US-030
- What was implemented: Created DecayEngine class for automatic tier demotion with audit logging
- Files changed:
  - extensions/memory-tiered/core/decay.ts (new)
- **Learnings for future iterations:**
  - DecayEngine takes db and optional ResolvedConfig as constructor dependencies
  - HOT demotion rule: age > hotTtlHours (default 72) → demote to COLD
  - WARM demotion rule: inactive > warmDemotionDays (default 60) → demote to COLD
  - Pinned memories excluded via WHERE clause (pinned = 0) - never checked for decay
  - Meta table stores key-value pairs for tracking last_decay_run; ensureMetaTable() creates if not exists
  - DecayResult includes hotDemoted, warmDemoted, totalProcessed, and runAt timestamp
  - shouldRun(intervalHours) checks if enough time has passed since last decay run
  - Audit entries use action='demote' with old_value/new_value containing tier in JSON format
  - Uses created_at for HOT demotion (based on age) and last_accessed_at for WARM (based on inactivity)
---

## 2026-01-31 - US-031
- What was implemented: Created PromotionEngine class for automatic tier promotion of frequently-used COLD memories
- Files changed:
  - extensions/memory-tiered/core/promotion.ts (new)
- **Learnings for future iterations:**
  - PromotionEngine takes db and optional ResolvedConfig as constructor dependencies
  - COLD promotion rule: use_count >= promotionUses (default 3) AND distinct days in use_days >= promotionDays (default 2)
  - Never auto-promote to HOT; only COLD → WARM promotion is automatic
  - Pinned memories excluded via WHERE clause (pinned = 0) - already have priority
  - PromotionResult includes promoted count, totalProcessed, and runAt timestamp
  - use_days is stored as JSON string in DB; parse with JSON.parse() and use Set to count distinct days
  - Audit entries use action='promote' with old_value/new_value containing tier in JSON format
  - Both DecayEngine and PromotionEngine share similar patterns for tier changes and audit logging
---

## 2026-01-31 - US-032
- What was implemented: Registered decay service in plugin with background scheduling for automatic tier decay and promotion
- Files changed:
  - extensions/memory-tiered/index.ts (updated)
- **Learnings for future iterations:**
  - ServiceDefinition interface requires id, description, start(), and stop() methods for OpenClaw registration
  - DecayService wraps DecayEngine and PromotionEngine, running both on each interval cycle
  - start() checks decayEngine.shouldRun(intervalHours) before running cycle to avoid duplicate runs
  - setInterval returns ReturnType<typeof setInterval> for proper typing across Node/browser
  - stop() must null out intervalId after clearInterval() for proper cleanup detection
  - Service is registered last in register() after all tools, hooks, and CLI commands
  - intervalMs calculated from config.decay.intervalHours (default 6 hours)
---
