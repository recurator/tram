# TRAM v0.2.0 Progress

Branch: ralph/tram-v0.2.0-intelligent-tuning
Started: 2026-02-03

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Add minScore to injection config schema | ✅ complete |
| US-002 | Filter candidates by minScore in auto-recall | ✅ complete |
| US-003 | Expose full config schema to OpenClaw | ✅ complete |
| US-004 | Backward compatibility with boolean autoRecall | ✅ complete |
| US-005 | Add decay overrides config schema | ✅ complete |
| US-006 | Implement category-aware decay in DecayEngine | ✅ complete |
| US-007 | Add sessions config schema | ✅ complete |
| US-008 | Detect session type at runtime | ✅ complete |
| US-009 | Session-aware auto-capture | ✅ complete |
| US-010 | Session-aware default tier | ✅ complete |
| US-011 | Create injection_feedback table | ✅ complete |
| US-012 | Create tuning_log table | ✅ complete |
| US-013 | Track proxy metrics post-injection | ✅ complete |
| US-014 | Update access metrics on memory recall | ✅ complete |
| US-015 | Add tuning config schema | ✅ complete |
| US-016 | Add reporting config schema | ✅ complete |
| US-017 | Implement auto-adjustment logic | ✅ complete |
| US-018 | Log tuning changes | ✅ complete |
| US-019 | Implement user parameter lock | ✅ complete |
| US-020 | Implement notification delivery | ✅ complete |
| US-021 | Add memory_stats metrics dashboard | ✅ complete |
| US-022 | Create benchmark dataset | ✅ complete |
| US-023 | Implement benchmark runner | ✅ complete |
| US-024 | Document OpenClaw 2026.2.1 compatibility | ✅ complete |
| US-025 | Assess before_tool_call integration | ✅ complete |

## Codebase Patterns
- Config changes require updating: InjectionConfigSchema, ResolvedConfig interface, DEFAULTS, resolveConfig(), and uiHints
- The codebase uses Zod schemas for validation with corresponding TypeScript interfaces
- UI hints use specific types: "slider" for 0-1 ranges, "number" for counts, "toggle" for booleans
- AutoRecallHook uses MemoryScorer for composite scoring; to filter by score, call scorer.score() directly before allocation
- Tests for auto_recall use mocked database, embedding provider, and vector helper
- For union types (boolean | object), use z.union([z.boolean(), ObjectSchema]) and resolve in resolveConfig()
- ResolvedConfig interfaces should have all fields required (not optional) to ensure type safety
- createAutoRecallHook extracts all settings from resolved config.autoRecall object (not raw config)
- Hook handlers use module-level state; to share data between hooks, use exported getter functions like getCurrentSessionType()
- Session type is accessed via ctx.session?.type and validated against known types; unknown defaults to "main"
- Tool wrappers in index.ts can modify input params before calling tool.execute() (e.g., inject _sessionDefaultTier)

## Log

## 2026-02-03 - US-001
- What was implemented: Added minScore configuration option to InjectionConfigSchema
- Files changed: config.ts
- **Learnings for future iterations:**
  - Config additions follow a 5-part pattern: schema field, ResolvedConfig interface, DEFAULTS, resolveConfig(), uiHints
  - Default values live in DEFAULTS constant (~line 198), not in schema defaults alone
  - uiHints sliders should have min/max/step defined for 0-1 range values
---

## 2026-02-03 - US-002
- What was implemented: Added minScore filtering to auto-recall hook before tier budget allocation
- Files changed: hooks/auto_recall.ts, __tests__/auto_recall.test.ts (new)
- **Learnings for future iterations:**
  - AutoRecallConfig interface must include new config options for them to be passed through
  - Filtering must happen BEFORE calling allocator.allocate() to affect tier budgets correctly
  - The scorer is already available as this.scorer in AutoRecallHook
  - Use >= not > for threshold comparisons to include memories at exact threshold
  - Empty result handling requires checking for current context before returning
  - createAutoRecallHook() factory function also needs updating to pass new config options
---

## 2026-02-03 - US-003
- What was implemented: Verified and documented that full config schema is exposed to OpenClaw
- Files changed: README.md (added injection.minScore documentation)
- **Learnings for future iterations:**
  - The configSchema export in index.ts includes both the Zod schema and uiHints
  - uiHints already covers all config sections: injection.*, scoring.*, tiers.*, decay.*
  - The configSchema.parse() is used in register() to parse and validate config from openclaw.json
  - README should document all config options to help users discover them
---

## 2026-02-03 - US-004
- What was implemented: Backward compatibility allowing autoRecall to be boolean or object
- Files changed: config.ts, hooks/auto_recall.ts, __tests__/config.test.ts (new)
- **Learnings for future iterations:**
  - Use z.union([z.boolean(), ObjectSchema]) for backward-compatible config options
  - Create a dedicated resolve function (resolveAutoRecall) to handle union type normalization
  - The ResolvedConfig interface should always use the fully-resolved object type, never the union
  - When the object form has optional values, fall back to injection config (not defaults) for DRY
  - Test backward compatibility explicitly: boolean true, boolean false, object with partial values, full v0.1.x configs
  - Empty object {} should be valid input, relying on defaults from injection config
---

## 2026-02-03 - US-005
- What was implemented: Added decay overrides config schema with per-memory-type TTLs
- Files changed: config.ts
- **Learnings for future iterations:**
  - Use z.record(MemoryTypeSchema, ValueSchema) for type-keyed maps with constrained keys
  - For nullable values, use z.union([z.number().min(1), z.null()]) to allow null or positive numbers
  - Create separate schemas for nested objects (DecayTTLOverrideSchema, DecayDefaultsSchema) for clarity
  - The MemoryTypeSchema must exactly match MemoryType enum values from core/types.ts
  - Default value for overrides should be an empty object {} cast to the proper type
  - uiHints for nested objects with per-type fields require explicit field definitions for each type
---

## 2026-02-03 - US-006
- What was implemented: Category-aware decay in DecayEngine with per-memory-type TTL overrides
- Files changed: core/decay.ts, __tests__/decay.test.ts (new)
- **Learnings for future iterations:**
  - DecayEngine uses config.decay.overrides[memory_type] for TTL lookup, falling back to config.decay.default
  - null TTL in overrides means the memory never demotes from that tier (e.g., procedural memories stay HOT forever)
  - MemoryRow interface in decay.ts needs memory_type field to access the memory's type
  - Audit log old_value and new_value should include memory_type in JSON context for debugging
  - Tests can use helper functions (insertMemory, getMemory) to directly manipulate SQLite via db.getDb()
  - The Database class wrapper doesn't have high-level CRUD methods; tests use raw SQL via better-sqlite3
---

## 2026-02-03 - US-007
- What was implemented: Added sessions config schema for per-session-type configuration (main, cron, spawned)
- Files changed: config.ts
- **Learnings for future iterations:**
  - Session settings use a separate TierValueSchema (not the MemoryTypeSchema) for tier selection
  - The pattern for adding new config sections is: Schema → MemoryTieredConfigSchema → ResolvedConfig → DEFAULTS → resolveConfig() → uiHints
  - SessionSettingsSchema requires all fields (defaultTier, autoCapture, autoInject) but SessionsConfigSchema makes each session type optional
  - uiHints for tier selection should use type="select" with options for each tier value
---

## 2026-02-03 - US-008
- What was implemented: Session type detection from OpenClaw context at runtime
- Files changed: hooks/auto-recall/handler.ts, hooks/auto-capture/handler.ts, __tests__/session_type.test.ts (new)
- **Learnings for future iterations:**
  - OpenClaw passes session info via ctx.session.type in hook context
  - Hook handlers use module-level state, so session type is stored in currentSessionType variable
  - getSessionType() validates against VALID_SESSION_TYPES array and defaults to "main" for unknown/missing
  - getCurrentSessionType() exported for hooks that need to access session type later
  - The handler checks config.sessions[sessionType].autoInject/autoCapture before proceeding
  - SessionContext interface added to AgentContext to type the ctx.session field
---

## 2026-02-03 - US-009
- What was implemented: Session-aware auto-capture that respects config.sessions[sessionType].autoCapture
- Files changed: __tests__/auto_capture_session.test.ts (new)
- **Learnings for future iterations:**
  - The handler in hooks/auto-capture/handler.ts already implements session-aware auto-capture
  - handler.ts checks both config.sessions[sessionType].autoCapture AND global config.autoCapture
  - Returns early (no capture) when either setting is false for the current session type
  - Default config: main={autoCapture:true}, cron={autoCapture:false}, spawned={autoCapture:false}
  - memory_store tool is independent of session settings - always works regardless of autoCapture flag
  - The PRD references hooks/auto_capture.ts but actual implementation is in hooks/auto-capture/handler.ts
---

## 2026-02-03 - US-010
- What was implemented: Session-aware default tier for auto-capture and memory_store
- Files changed: hooks/auto-capture/handler.ts, tools/memory_store.ts, index.ts, __tests__/session_default_tier.test.ts (new)
- **Learnings for future iterations:**
  - Auto-capture's storeMemory() function needs a tier parameter; use config.sessions[currentSessionType].defaultTier
  - For memory_store tool, add internal _sessionDefaultTier param passed from index.ts execute wrapper
  - getCurrentSessionType() from auto-capture handler provides session type for memory_store tool
  - Tier resolution priority: explicit tier param > session default > HOT (ultimate fallback)
  - The TierValue from config ("HOT"/"COLD"/"WARM") can be cast directly to Tier enum
  - Tool wrappers in index.ts can access config and modify params before calling tool.execute()
---

## 2026-02-03 - US-011
- What was implemented: Created injection_feedback table for tracking injection outcomes
- Files changed: db/sqlite.ts, core/types.ts, __tests__/injection_feedback.test.ts (new)
- **Learnings for future iterations:**
  - Database schema changes are added to the initialize() method in db/sqlite.ts using CREATE TABLE IF NOT EXISTS (idempotent)
  - Foreign keys use ON DELETE CASCADE to auto-clean related records
  - Indexes are created in separate CREATE INDEX IF NOT EXISTS statements for clarity
  - New table types should be added to core/types.ts as TypeScript interfaces
  - Test patterns: use helper functions to insert/retrieve records via raw SQL db.getDb()
  - Foreign key constraints require `PRAGMA foreign_keys = ON` to be enforced in tests
---

## 2026-02-03 - US-012
- What was implemented: Created tuning_log table for tracking parameter adjustments
- Files changed: db/sqlite.ts, core/types.ts, __tests__/tuning_log.test.ts (new)
- **Learnings for future iterations:**
  - tuning_log table follows same pattern as injection_feedback: CREATE TABLE IF NOT EXISTS in initialize()
  - Use CHECK constraint for enum-like columns: `CHECK (source IN ('auto', 'agent', 'user'))`
  - Indexes on timestamp and parameter columns for efficient lookup of recent changes and per-parameter history
  - TuningSource type added for type-safe source values
  - reverted column uses INTEGER (0/1) since SQLite has no native boolean type
---

## 2026-02-03 - US-013
- What was implemented: Track proxy metrics post-injection by recording injection_feedback entries
- Files changed: hooks/auto-recall/handler.ts, __tests__/proxy_metrics.test.ts (new)
- **Learnings for future iterations:**
  - recordInjectionMetrics function inserts injection_feedback for each injected memory
  - Use setImmediate() to defer metrics recording so it doesn't block the injection response
  - injection_density = injected_count / total_candidates (from hybridResults.length)
  - session_key comes from ctx.sessionKey in AgentContext; defaults to "unknown" if not provided
  - access_frequency starts at 0 and will be incremented by US-014 when memories are recalled
  - TierBudgetAllocator with small maxItems (e.g., 2) may allocate 0 slots due to Math.floor() on percentages
  - Test async behavior with flushSetImmediate() helper: `new Promise(resolve => setImmediate(resolve))`
---

## 2026-02-03 - US-014
- What was implemented: Update access_frequency in injection_feedback when memories are recalled
- Files changed: tools/memory_recall.ts, __tests__/access_frequency.test.ts (new)
- **Learnings for future iterations:**
  - The updateAccessStats() method in MemoryRecallTool already increments memory use_count; extend it for feedback
  - Find most recent injection_feedback by ORDER BY injected_at DESC LIMIT 1 for the memory_id
  - Skip silently when no feedback exists (memory wasn't auto-injected via auto-recall)
  - Both use_count in memories table and access_frequency in injection_feedback track usage, but for different purposes
  - The feedback tracking enables measuring "usefulness" of injected memories over time
  - Test patterns follow proxy_metrics.test.ts: helper functions for inserting/getting feedback entries
---


## 2026-02-03 - US-015
- What was implemented: Verified tuning config schema already present in config.ts
- Files changed: None (already implemented)
- **Learnings for future iterations:**
  - TuningConfigSchema with enabled, mode, autoAdjust, and lockDurationDays was already added
  - TuningModeSchema enum includes auto, manual, hybrid options
  - AutoAdjustConfigSchema contains TuningBoundsSchema (min/max/step) and TierTargetSizeSchema (min/max)
  - Defaults in DEFAULTS constant: enabled=true, mode="hybrid", lockDurationDays=7
  - importanceThreshold bounds default: min=0.1, max=0.9, step=0.05
  - hotTargetSize default: min=10, max=50
  - warmTargetSize default: min=50, max=200
  - resolveConfig() properly handles nested tuning.autoAdjust paths
---

## 2026-02-03 - US-016
- What was implemented: Added reporting config schema with enabled, channel, frequency, includeMetrics fields
- Files changed: config.ts
- **Learnings for future iterations:**
  - ReportingChannelSchema enum: telegram, discord, slack, log, none
  - ReportingFrequencySchema enum: on-change, daily-summary, weekly-summary
  - Defaults: enabled=true, channel=log, frequency=on-change, includeMetrics=true
  - The config pattern for new sections: Schema → MemoryTieredConfigSchema → ResolvedConfig → DEFAULTS → resolveConfig() → uiHints
  - uiHints for select fields use options array with value/label objects
---

## 2026-02-03 - US-017
- What was implemented: TuningEngine class for auto-adjustment of importanceThreshold based on HOT tier size
- Files changed: core/tuning.ts (new), index.ts, __tests__/tuning_engine.test.ts (new)
- **Learnings for future iterations:**
  - TuningEngine follows the same pattern as DecayEngine: constructor(db, config), run() method
  - Use getTierCounts() to query current tier sizes, excluding do_not_inject memories
  - getCurrentImportanceThreshold() looks up the most recent non-reverted tuning_log entry, falls back to injection.minScore
  - isParameterLocked() checks user_override_until against current date to respect user locks
  - Adjustment logic: if HOT > max target, increase threshold; if HOT < min target, decrease threshold
  - Always clamp new values to bounds (min/max) using Math.min/Math.max
  - TuningEngine is integrated into DecayService.runCycle() after decay and promotion engines
  - tuning_log entries store values as JSON strings for flexibility with different parameter types
---

## 2026-02-03 - US-018
- What was implemented: Logging of tuning changes (already completed as part of US-017)
- Files changed: None (implemented in core/tuning.ts as part of US-017)
- **Learnings for future iterations:**
  - TuningEngine.logTuningChange() creates tuning_log entries for all parameter changes
  - Entries include: parameter, old_value, new_value, reason, source, timestamp (all in DB schema)
  - The reason field is human-readable: e.g., "HOT tier exceeded target (60 > 50)"
  - tuning_engine.test.ts already tests that entries are created with correct fields
  - When stories have overlapping functionality, implement in the first story and mark both as complete
---

## 2026-02-03 - US-019
- What was implemented: User parameter lock/unlock CLI commands
- Files changed: cli/lock.ts (new), core/tuning.ts, index.ts, __tests__/lock_unlock.test.ts (new)
- **Learnings for future iterations:**
  - CLI commands registered in index.ts follow Commander.js callback pattern with program.command()
  - Lock/unlock creates tuning_log entries with user_override_until set or cleared
  - isParameterLocked must check the MOST RECENT entry, not just entries with a lock
  - SQLite ORDER BY timestamp DESC can be nondeterministic for same-millisecond entries; use rowid as tiebreaker
  - MemoryLockCommand uses config.tuning.lockDurationDays for lock expiration
  - LOCKABLE_PARAMETERS constant defines valid parameter names (currently only importanceThreshold)
---

## 2026-02-03 - US-020
- What was implemented: TuningReporter for notification delivery when TRAM auto-tunes
- Files changed: services/reporter.ts (new), index.ts, __tests__/reporter.test.ts (new)
- **Learnings for future iterations:**
  - New services go in the services/ directory (created for this story)
  - TuningReporter is integrated into DecayService.runCycle() after TuningEngine.run()
  - Channel delivery uses async fetch() for external webhooks (telegram, discord, slack) but synchronous for log
  - When env vars aren't configured for a channel, fall back to log with a warning message
  - Frequency modes (daily-summary, weekly-summary) batch notifications and check time boundaries
  - For batching: don't auto-send when lastSummary is null (wait for explicit flush or time boundary)
  - Test channel fallback by temporarily deleting env vars and restoring after test
  - Use vi.spyOn(console, 'log') to capture log output for assertions
---

## 2026-02-03 - US-021
- What was implemented: Added --metrics option to tram stats command for tuning metrics dashboard
- Files changed: cli/stats.ts, index.ts, __tests__/stats_metrics.test.ts (new)
- **Learnings for future iterations:**
  - CLI command options are added both in cli/*.ts class and in index.ts registerCli callback
  - The stats command already had a pattern for optional data sections (contextStatus, embeddingInfo)
  - For aggregate queries on optional tables, check if table exists with sqlite_master query first
  - JSON values in tuning_log need JSON.parse() when reading and JSON.stringify() when writing
  - Use toFixed() for numeric display formatting in CLI output
  - Status indicators (OK, ABOVE, BELOW) help users quickly see if values are within target ranges
  - Test patterns: create tables in beforeEach, use helper functions for inserts, test both JSON and text output
---

## 2026-02-03 - US-022
- What was implemented: Created benchmark dataset for measuring TRAM retrieval quality
- Files changed: tests/benchmark/dataset.json (new), tests/benchmark/queries.json (new)
- **Learnings for future iterations:**
  - Benchmark datasets are JSON files in tests/benchmark/ directory (not __tests__)
  - Each memory in dataset.json needs: id, text, memory_type, ground_truth_queries
  - Each query in queries.json needs: id, text, relevant_memory_ids, category
  - The 4 memory types from core/types.ts: factual, procedural, episodic, project
  - Coverage should include edge cases: synonyms, temporal references, multi-type queries
  - Query categories help analyze which query types perform well/poorly in benchmarks
  - Dataset IDs use format "mem-{type}-{number}" for easy identification
---

## 2026-02-03 - US-023
- What was implemented: Benchmark runner script for TRAM vs OpenClaw retrieval comparison
- Files changed: tests/benchmark/run.ts (new), tests/benchmark/results.json (new)
- **Learnings for future iterations:**
  - Benchmark script uses mock embeddings (deterministic hash-based) for reproducibility without LLM API calls
  - Test conditions are defined as config objects: scoringWeights, minScore, vectorWeight, textWeight
  - IR metrics: Precision@K counts relevant in top K; Recall@K counts fraction of all relevant found; MRR is 1/rank of first relevant; nDCG normalizes against ideal ranking
  - idcgAtK (ideal DCG) assumes all relevant items at top positions
  - For benchmark scripts, create fresh in-memory database per condition to avoid state leakage
  - Group query results by category base name (split on "-") for category breakdown analysis
  - VectorHelper.hybridSearch combines FTS text matching with cosine similarity via configurable weights
  - The benchmark infrastructure enables A/B testing different scoring strategies
---

## 2026-02-03 - US-024
- What was implemented: Comprehensive OpenClaw 2026.2.1 compatibility documentation
- Files changed: docs/openclaw-2026.2.1-compat.md (new)
- **Learnings for future iterations:**
  - TRAM uses api.on() for hook registration (before_agent_start, agent_end)
  - L2 normalization is handled by embedding providers: local uses normalize:true, OpenAI returns pre-normalized vectors
  - The cosineSimilarity function in VectorHelper handles both normalized and non-normalized vectors correctly
  - OpenClaw 2026.2.1 introduces before_tool_call hook but TRAM doesn't need it currently
  - Documentation should include test commands for verifying compatibility
  - Version compatibility matrices help users understand upgrade paths
---

## 2026-02-03 - US-025
- What was implemented: Comprehensive before_tool_call integration assessment with working prototype
- Files changed: docs/openclaw-2026.2.1-compat.md (updated), hooks/before-tool-call/handler.ts (new)
- **Learnings for future iterations:**
  - before_tool_call hook fires AFTER param validation but BEFORE tool.execute()
  - Hook receives toolName, toolCallId, params, and session context (same as other hooks)
  - prependContext return value injects text into agent context before tool result
  - Tool category mapping (code/search/file/web/memory/system) enables targeted memory injection
  - Memory tools should skip injection to avoid recursion (memory_recall calling memory_recall)
  - Performance overhead: 50-500ms per tool call depending on embedding provider
  - For frequently-called tools (bash, file), overhead is significant; for slow tools (web_search), it's negligible
  - Prototype pattern: module-level state initialized via initXxxHook(), handler exported as default
---
