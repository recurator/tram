# TRAM v0.2.0 Progress

Branch: ralph/tram-v0.2.0-intelligent-tuning
Started: 2026-02-03

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Add minScore to injection config schema | ✅ complete |
| US-002 | Filter candidates by minScore in auto-recall | ✅ complete |
| US-003 | Expose full config schema to OpenClaw | ✅ complete |
| US-004 | Backward compatibility with boolean autoRecall | ✅ complete |
| US-005 | Add decay overrides config schema | ✅ complete |
| US-006 | Implement category-aware decay in DecayEngine | ✅ complete |
| US-007 | Add sessions config schema | ✅ complete |
| US-008 | Detect session type at runtime | ✅ complete |
| US-009 | Session-aware auto-capture | ✅ complete |
| US-010 | Session-aware default tier | ✅ complete |
| US-011 | Create injection_feedback table | ✅ complete |
| US-012 | Create tuning_log table | ✅ complete |
| US-013 | Track proxy metrics post-injection | pending |
| US-014 | Update access metrics on memory recall | pending |
| US-015 | Add tuning config schema | pending |
| US-016 | Add reporting config schema | pending |
| US-017 | Implement auto-adjustment logic | pending |
| US-018 | Log tuning changes | pending |
| US-019 | Implement user parameter lock | pending |
| US-020 | Implement notification delivery | pending |
| US-021 | Add memory_stats metrics dashboard | pending |
| US-022 | Create benchmark dataset | pending |
| US-023 | Implement benchmark runner | pending |
| US-024 | Document OpenClaw 2026.2.1 compatibility | pending |
| US-025 | Assess before_tool_call integration | pending |

## Codebase Patterns
- Config changes require updating: InjectionConfigSchema, ResolvedConfig interface, DEFAULTS, resolveConfig(), and uiHints
- The codebase uses Zod schemas for validation with corresponding TypeScript interfaces
- UI hints use specific types: "slider" for 0-1 ranges, "number" for counts, "toggle" for booleans
- AutoRecallHook uses MemoryScorer for composite scoring; to filter by score, call scorer.score() directly before allocation
- Tests for auto_recall use mocked database, embedding provider, and vector helper
- For union types (boolean | object), use z.union([z.boolean(), ObjectSchema]) and resolve in resolveConfig()
- ResolvedConfig interfaces should have all fields required (not optional) to ensure type safety
- createAutoRecallHook extracts all settings from resolved config.autoRecall object (not raw config)
- Hook handlers use module-level state; to share data between hooks, use exported getter functions like getCurrentSessionType()
- Session type is accessed via ctx.session?.type and validated against known types; unknown defaults to "main"
- Tool wrappers in index.ts can modify input params before calling tool.execute() (e.g., inject _sessionDefaultTier)

## Log

## 2026-02-03 - US-001
- What was implemented: Added minScore configuration option to InjectionConfigSchema
- Files changed: config.ts
- **Learnings for future iterations:**
  - Config additions follow a 5-part pattern: schema field, ResolvedConfig interface, DEFAULTS, resolveConfig(), uiHints
  - Default values live in DEFAULTS constant (~line 198), not in schema defaults alone
  - uiHints sliders should have min/max/step defined for 0-1 range values
---

## 2026-02-03 - US-002
- What was implemented: Added minScore filtering to auto-recall hook before tier budget allocation
- Files changed: hooks/auto_recall.ts, __tests__/auto_recall.test.ts (new)
- **Learnings for future iterations:**
  - AutoRecallConfig interface must include new config options for them to be passed through
  - Filtering must happen BEFORE calling allocator.allocate() to affect tier budgets correctly
  - The scorer is already available as this.scorer in AutoRecallHook
  - Use >= not > for threshold comparisons to include memories at exact threshold
  - Empty result handling requires checking for current context before returning
  - createAutoRecallHook() factory function also needs updating to pass new config options
---

## 2026-02-03 - US-003
- What was implemented: Verified and documented that full config schema is exposed to OpenClaw
- Files changed: README.md (added injection.minScore documentation)
- **Learnings for future iterations:**
  - The configSchema export in index.ts includes both the Zod schema and uiHints
  - uiHints already covers all config sections: injection.*, scoring.*, tiers.*, decay.*
  - The configSchema.parse() is used in register() to parse and validate config from openclaw.json
  - README should document all config options to help users discover them
---

## 2026-02-03 - US-004
- What was implemented: Backward compatibility allowing autoRecall to be boolean or object
- Files changed: config.ts, hooks/auto_recall.ts, __tests__/config.test.ts (new)
- **Learnings for future iterations:**
  - Use z.union([z.boolean(), ObjectSchema]) for backward-compatible config options
  - Create a dedicated resolve function (resolveAutoRecall) to handle union type normalization
  - The ResolvedConfig interface should always use the fully-resolved object type, never the union
  - When the object form has optional values, fall back to injection config (not defaults) for DRY
  - Test backward compatibility explicitly: boolean true, boolean false, object with partial values, full v0.1.x configs
  - Empty object {} should be valid input, relying on defaults from injection config
---

## 2026-02-03 - US-005
- What was implemented: Added decay overrides config schema with per-memory-type TTLs
- Files changed: config.ts
- **Learnings for future iterations:**
  - Use z.record(MemoryTypeSchema, ValueSchema) for type-keyed maps with constrained keys
  - For nullable values, use z.union([z.number().min(1), z.null()]) to allow null or positive numbers
  - Create separate schemas for nested objects (DecayTTLOverrideSchema, DecayDefaultsSchema) for clarity
  - The MemoryTypeSchema must exactly match MemoryType enum values from core/types.ts
  - Default value for overrides should be an empty object {} cast to the proper type
  - uiHints for nested objects with per-type fields require explicit field definitions for each type
---

## 2026-02-03 - US-006
- What was implemented: Category-aware decay in DecayEngine with per-memory-type TTL overrides
- Files changed: core/decay.ts, __tests__/decay.test.ts (new)
- **Learnings for future iterations:**
  - DecayEngine uses config.decay.overrides[memory_type] for TTL lookup, falling back to config.decay.default
  - null TTL in overrides means the memory never demotes from that tier (e.g., procedural memories stay HOT forever)
  - MemoryRow interface in decay.ts needs memory_type field to access the memory's type
  - Audit log old_value and new_value should include memory_type in JSON context for debugging
  - Tests can use helper functions (insertMemory, getMemory) to directly manipulate SQLite via db.getDb()
  - The Database class wrapper doesn't have high-level CRUD methods; tests use raw SQL via better-sqlite3
---

## 2026-02-03 - US-007
- What was implemented: Added sessions config schema for per-session-type configuration (main, cron, spawned)
- Files changed: config.ts
- **Learnings for future iterations:**
  - Session settings use a separate TierValueSchema (not the MemoryTypeSchema) for tier selection
  - The pattern for adding new config sections is: Schema → MemoryTieredConfigSchema → ResolvedConfig → DEFAULTS → resolveConfig() → uiHints
  - SessionSettingsSchema requires all fields (defaultTier, autoCapture, autoInject) but SessionsConfigSchema makes each session type optional
  - uiHints for tier selection should use type="select" with options for each tier value
---

## 2026-02-03 - US-008
- What was implemented: Session type detection from OpenClaw context at runtime
- Files changed: hooks/auto-recall/handler.ts, hooks/auto-capture/handler.ts, __tests__/session_type.test.ts (new)
- **Learnings for future iterations:**
  - OpenClaw passes session info via ctx.session.type in hook context
  - Hook handlers use module-level state, so session type is stored in currentSessionType variable
  - getSessionType() validates against VALID_SESSION_TYPES array and defaults to "main" for unknown/missing
  - getCurrentSessionType() exported for hooks that need to access session type later
  - The handler checks config.sessions[sessionType].autoInject/autoCapture before proceeding
  - SessionContext interface added to AgentContext to type the ctx.session field
---

## 2026-02-03 - US-009
- What was implemented: Session-aware auto-capture that respects config.sessions[sessionType].autoCapture
- Files changed: __tests__/auto_capture_session.test.ts (new)
- **Learnings for future iterations:**
  - The handler in hooks/auto-capture/handler.ts already implements session-aware auto-capture
  - handler.ts checks both config.sessions[sessionType].autoCapture AND global config.autoCapture
  - Returns early (no capture) when either setting is false for the current session type
  - Default config: main={autoCapture:true}, cron={autoCapture:false}, spawned={autoCapture:false}
  - memory_store tool is independent of session settings - always works regardless of autoCapture flag
  - The PRD references hooks/auto_capture.ts but actual implementation is in hooks/auto-capture/handler.ts
---

## 2026-02-03 - US-010
- What was implemented: Session-aware default tier for auto-capture and memory_store
- Files changed: hooks/auto-capture/handler.ts, tools/memory_store.ts, index.ts, __tests__/session_default_tier.test.ts (new)
- **Learnings for future iterations:**
  - Auto-capture's storeMemory() function needs a tier parameter; use config.sessions[currentSessionType].defaultTier
  - For memory_store tool, add internal _sessionDefaultTier param passed from index.ts execute wrapper
  - getCurrentSessionType() from auto-capture handler provides session type for memory_store tool
  - Tier resolution priority: explicit tier param > session default > HOT (ultimate fallback)
  - The TierValue from config ("HOT"/"COLD"/"WARM") can be cast directly to Tier enum
  - Tool wrappers in index.ts can access config and modify params before calling tool.execute()
---

## 2026-02-03 - US-011
- What was implemented: Created injection_feedback table for tracking injection outcomes
- Files changed: db/sqlite.ts, core/types.ts, __tests__/injection_feedback.test.ts (new)
- **Learnings for future iterations:**
  - Database schema changes are added to the initialize() method in db/sqlite.ts using CREATE TABLE IF NOT EXISTS (idempotent)
  - Foreign keys use ON DELETE CASCADE to auto-clean related records
  - Indexes are created in separate CREATE INDEX IF NOT EXISTS statements for clarity
  - New table types should be added to core/types.ts as TypeScript interfaces
  - Test patterns: use helper functions to insert/retrieve records via raw SQL db.getDb()
  - Foreign key constraints require `PRAGMA foreign_keys = ON` to be enforced in tests
---

## 2026-02-03 - US-012
- What was implemented: Created tuning_log table for tracking parameter adjustments
- Files changed: db/sqlite.ts, core/types.ts, __tests__/tuning_log.test.ts (new)
- **Learnings for future iterations:**
  - tuning_log table follows same pattern as injection_feedback: CREATE TABLE IF NOT EXISTS in initialize()
  - Use CHECK constraint for enum-like columns: `CHECK (source IN ('auto', 'agent', 'user'))`
  - Indexes on timestamp and parameter columns for efficient lookup of recent changes and per-parameter history
  - TuningSource type added for type-safe source values
  - reverted column uses INTEGER (0/1) since SQLite has no native boolean type
---

